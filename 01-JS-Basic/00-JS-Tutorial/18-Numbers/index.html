<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <h1>Number</h1>
<script>
    var num1 = 100; // integer
    console.log(num1);
		
    var num2 = -100; //negative integer
    console.log(num2);

		var num3 = 10.52; // float
    console.log(num3);
		
    var num4 = -10.52; //negative float
    console.log(num4);

		var num5 = 0xfff; // hexadecimal
    console.log(num5);
		
    var num6 = 256e-5; // exponential
    console.log(num6);
		
    var num7 = 030; // octal
    console.log(num7);
		
    var num8 = 0b0010001; // binary
    console.log(num8);




</script>

  <script>
    //Numbers can be written with or without decimals:

    let x = 5; // Declaration
    console.log(x);
    let y=3.14;
    console.log(y);

    //1.Number Literals: The types of number literals You can use decimal, binary, octal, and hexadecimal.
    let myVaria = '423';
    let myNum = 423;
    let myFloa = 22.32;
    console.log(myNum === myVaria);//false
    console.log(myVaria + 3);//4233
    console.log(Number(myVaria) + 3);//4236
    console.log(Number(true) + 3);//4

    //2.Decimal Numbers: JavaScript Numbers does not have different types of numbers(ex: int, float, long, short) which other programming languages do. It has only one type of number and it can hold both with or without decimal values.

    //example:
    var x1 = 0.22 + 0.12;
    console.log(x1);

    //Binary Numbers: They start with 0b or 0B followed by 0’s and 1’s.

    var x2 = 0b0111;
    console.log(x2);

    //Octal Numbers: They start with 0 followed by a number of ranges from 0-7. If any number is used it will be taken as a decimal number.

    var x3 = 07123;
    console.log(x3);

    //Hexadecimal Numbers: They start with 0x or 0X followed by any digit belonging (0123456789ABCDEF)

    var x4 = 0xfff;
    console.log(x4);

    //Exponentiation:
    var x5 = 2e5; // x will be 200000
    console.log(x5);

    //Addition:
    var a = 20;
    var b = 20;
    var c = a + b; // c will be 40 (a number)

    //Concatenation:

    var a1 = '10';
    var b1 = '20';
    var c1 = a1 + b1; // c1 will be 1020 (a string)

    //Numeric Strings:
    var x6 = '12345'; // x will be a string(NaN)
    var x7 = 67; // x will be number

    //3.JavaScript Numbers as Objects

    // x is a number
    let x8 = 123;

    // y is a Number object
    let y8 = new Number(123);
    console.log(typeof x8, typeof y8);
    console.log(x8 == y8); //true

    //integer number Precision
    let x1=999999999999999;
    let x2=9999999999999999;
    console.log(x1);
    console.log(x2);

    //float Number Precision
    let a = 1.1 + 1.3;
    console.log(a);//2.4000000000000004


    //Negative Number
    let h = -1;
    console.log(h);//-1
    h = 2 - -1;
    console.log(h);//3
    h = 2 - (-1);
    console.log(h);//3
    h = 0;
    console.log(--h);//-1



    //NaN-Not a Number
    console.log(100/"apple");//Nan
    console.log(100/"10");//10

    let x2 = 100 / "Apple";
   console.log(isNaN(x2));


   //Infinity

   let x3 =  2 / 0;
   console.log(x3);
let y3 = -2 / 0;
console.log(y3);



//5.More ways to write a number

//Imagine we need to write 1 billion. The obvious way is:

let billion = 1000000000;

//We also can use underscore _ as the separator:

let billion1 = 1_000_000_000;

//In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:

let billion2 = 1e9;  // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 );  // 7.3 billions (same as 7300000000 or 7_300_000_000)

/*
In other words, e multiplies the number by 1 with the given zeroes count.

1e3 === 1 * 1000; // e3 means *1000
1.23e6 === 1.23 * 1000000; // e6 means *1000000
*/

/*
Now let’s write something very small. Say, 1 microsecond (one millionth of a second):

let mсs = 0.000001;
Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:

let mcs = 1e-6; // five zeroes to the left from 1

*/

/*
In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

// -3 divides by 1 with 3 zeroes
1e-3 === 1 / 1000; // 0.001

// -6 divides by 1 with 6 zeroes
1.23e-6 === 1.23 / 1000000; // 0.00000123

// an example with a bigger number
1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times
*/

//4.Hex, binary and octal numbers

alert( 0xff ); // 255
alert( 0xFF ); // 255 (the same, case doesn't matter)


//Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:

let a = 0b11111111; // binary form of 255
let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides

//5.toString(base)
//The method num.toString(base) returns a string representation of num in the numeral system with the given base.

//For example:

let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

/*
Common use cases for this are:

base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.

base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.

base=36 is the maximum, digits can be 0..9 or A..Z. The whole latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral system with base 36:

alert( 123456..toString(36) ); // 2n9c

*/


//5.Imprecise calculations
alert( 1e500 ); // Infinity
alert( 0.1 + 0.2 == 0.3 ); // false
alert( 0.1 + 0.2 ); // 0.30000000000000004


//6.Tests: isFinite and isNaN

//i.isNaN(value) converts its argument to a number and then tests it for being NaN:

alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true

alert( NaN === NaN ); // false

//ii.isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:

alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, because a special value: NaN
alert( isFinite(Infinity) ); // false, because a special value: Infinity


//Sometimes isFinite is used to validate whether a string value is a regular number:

let num2 = +prompt("Enter a number", '');

// will be true unless you enter Infinity, -Infinity or not a number
alert( isFinite(num2) );

//iii.Number.isNaN(value) returns true if the argument belongs to the number type and it is NaN. In any other case it returns false.

alert( Number.isNaN(NaN) ); // true
alert( Number.isNaN("str" / 2) ); // true

// Note the difference:
alert( Number.isNaN("str") ); // false, because "str" belongs to the string type, not the number type
alert( isNaN("str") ); // true, because isNaN converts string "str" into a number and gets NaN as a result of this conversion


//iv.Number.isFinite(value) returns true if the argument belongs to the number type and it is not NaN/Infinity/-Infinity. In any other case it returns false.

alert( Number.isFinite(123) ); // true
alert( Number.isFinite(Infinity) ); // false
alert( Number.isFinite(2 / 0) ); // false

// Note the difference:
alert( Number.isFinite("123") ); // false, because "123" belongs to the string type, not the number type
alert( isFinite("123") ); // true, because isFinite converts string "123" into a number 123
  </script>

  <script src="./script.js"></script>
</body>

</html>