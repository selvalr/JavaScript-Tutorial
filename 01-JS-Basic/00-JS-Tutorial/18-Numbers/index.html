<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <h1>Number</h1>
    <!--
    <script>
      var num1 = 100; // integer
      console.log(num1); //100

      var num2 = -100; //negative integer
      console.log(num2); //-100

      var num3 = 10.52; // float
      console.log(num3); //10.52

      var num4 = -10.52; //negative float
      console.log(num4); //-10.52

      var num5 = 0xfff; // hexadecimal
      console.log(num5); //4095

      var num6 = 256e-5; // exponential
      console.log(num6); //0.00256
      /*
      var num7 = 030; // octal
      console.log(num7);
      */
      var num8 = 0b0010001; // binary
      console.log(num8); //17
    </script>

  -->

    <script>
      //i.Numbers can be written with or without decimals:
      /*
            let x = 5; // A number with decimals
            console.log(x);
            let y = 3.14; // A number without decimals
            console.log(y);
      */

      //1.Number Literals: The types of number literals You can use decimal, binary, octal, and hexadecimal.
      /*
      let myVaria = "423";
      let myNum = 423;
      let myFloa = 22.32;
      console.log(myNum === myVaria); //false
      console.log(myVaria + 3); //4233
      console.log(Number(myVaria) + 3); //4236
      console.log(Number(true) + 3); //4
      */

      //2.Decimal Numbers: JavaScript Numbers does not have different types of numbers(ex: int, float, long, short) which other programming languages do. It has only one type of number and it can hold both with or without decimal values.
      /*
      //example:
      var x1 = 0.22 + 0.12;
      console.log(x1); //0.33999999999999997

      //Binary Numbers: They start with 0b or 0B followed by 0’s and 1’s.

      var x2 = 0b0111;
      console.log(x2); //7
      */

      //Octal Numbers: They start with 0 followed by a number of ranges from 0-7. If any number is used it will be taken as a decimal number.
      /*
      var x3 = 07123;
      console.log(x3);
      */

      //Hexadecimal Numbers: They start with 0x or 0X followed by any digit belonging (0123456789ABCDEF)
      /*
      var x4 = 0xfff;
      console.log(x4); //4095

      //ii.Exponentiation:
      //Extra large or extra small numbers can be written with scientific (exponent) notation:

      var x5 = 2e5; // x will be 200000
      console.log(x5); //200000

      let x12 = 123e5; // 12300000
      let y12 = 123e-5; // 0.00123

      //Addition:
      //If you add two numbers, the result will be a number:

      var a = 20;
      var b = 20;
      var c = a + b; // c will be 40 (a number)

      //Concatenation:
      //If you add two strings, the result will be a string concatenation:

      var a1 = "10";
      var b1 = "20";
      var c1 = a1 + b1; // c1 will be 1020 (a string)

      //Numeric Strings:
      //If you add a number and a string, the result will be a string concatenation:

      let x00 = 10;
      let y00 = "20";
      let z00 = x00 + y00;
      console.log(z00); //1020


      //If you add a string and a number, the result will be a string concatenation:

      var x6 = "12345"; // x will be a string(NaN)
      var x7 = 67; // x will be number
      */

      /*
                  This will work:

                  let x = "100";
                  let y = "10";
                  let z = x / y;

                  This will also work:

                  let x = "100";
                  let y = "10";
                  let z = x * y;

                  And this will work:

                  let x = "100";
                  let y = "10";
                  let z = x - y;

                  But this will not work:

                  let x = "100";
                  let y = "10";
                  let z = x + y;


      */

      /*
      //A common mistake is to expect this result to be 30:

      let x01 = 10;
      let y01 = 20;
      let z01 = "The result is: " + x01 + y01;
      console.log(z01); //1020

      //A common mistake is to expect this result to be 102030:

      let x02 = 10;
      let y02 = 20;
      let z02 = "30";
      let result = x02 + y02 + z02;
      console.log(result); //3030
      */

      //3.JavaScript Numbers as Objects
      /*
      // x is a number
      let x8 = 123;

      // y is a Number object
      let y8 = new Number(123);
      console.log(typeof x8, typeof y8);
      console.log(x8 == y8); //true
      console.log(x8 === y8); //false

      //Note the difference between (x==y) and (x===y).

      let $x = new Number(500);
      let $y = new Number(500);
      console.log($x == $y); //false
      console.log($x === $y); //false

      //i.integer number Precision
      let x11 = 999999999999999; // x will be 999999999999999
      let x21 = 9999999999999999; // y will be 10000000000000000

      console.log(x11);
      console.log(x21);

      //float Number Precision
      let a = 1.1 + 1.3;
      console.log(a); //2.4000000000000004
      //To solve the problem above, it helps to multiply and divide:
      let x13 = (0.2 * 10 + 0.1 * 10) / 10;
      console.log(x13); //0.3

      //Negative Number
      let h = -1;
      console.log(h); //-1
      h = 2 - -1;
      console.log(h); //3
      h = 2 - -1;
      console.log(h); //3
      h = 0;
      console.log(--h); //-1

      //i.NaN-Not a Number
      //NaN is a JavaScript reserved word indicating that a number is not a legal number.

      //Trying to do arithmetic with a non-numeric string will result in NaN (Not a Number):
      console.log(100 / "apple"); //Nan
      console.log(100 / "10"); //10

      let x2 = 100 / "Apple";
      console.log(isNaN(x2));
      */

      /*
          // Watch out for NaN. If you use NaN in a mathematical operation, the result will also be NaN:

             //Example
                  let x = NaN;
                  let y = 5;
                  let z = x + y;

                  //Or the result might be a concatenation like NaN5:

                  //Example
                  let x = NaN;
                  let y = "5";
                  let z = x + y;

                 // NaN is a number: typeof NaN returns number:

                  //Example

                  typeof NaN;

      */

      /*
            //Infinity

            //Infinity (or -Infinity) is the value JavaScript will return if you calculate a number outside the largest possible number.
            let myNumber = 2;
            // Execute until Infinity
            while (myNumber != Infinity) {
              myNumber = myNumber * myNumber;
            }

            //Division by 0 (zero) also generates Infinity:

            let x3 = 2 / 0;
            console.log(x3);
            let y3 = -2 / 0;
            console.log(y3);

            //Infinity is a number: typeof Infinity returns number.

            console.log(typeof Infinity);

            //5.More ways to write a number

            //Imagine we need to write 1 billion. The obvious way is:

            let billion = 1000000000;

            //We also can use underscore _ as the separator:

            let billion1 = 1_000_000_000;

            //In JavaScript, we can shorten a number by appending the letter "e" to it and specifying the zeroes count:

            let billion2 = 1e9; // 1 billion, literally: 1 and 9 zeroes

            console.log(7.3e9); // 7.3 billions (same as 7300000000 or 7_300_000_000)
      */
      /*
                              In other words, e multiplies the number by 1 with the given zeroes count.

                              1e3 === 1 * 1000; // e3 means *1000
                              1.23e6 === 1.23 * 1000000; // e6 means *1000000
       */

      /*
                              Now let’s write something very small. Say, 1 microsecond (one millionth of a second):

                              let mсs = 0.000001;
                              Just like before, using "e" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:

                              let mcs = 1e-6; // five zeroes to the left from 1

      */

      /*
                              In other words, a negative number after "e" means a division by 1 with the given number of zeroes:

                              // -3 divides by 1 with 3 zeroes
                              1e-3 === 1 / 1000; // 0.001

                              // -6 divides by 1 with 6 zeroes
                              1.23e-6 === 1.23 / 1000000; // 0.00000123

                              // an example with a bigger number
                              1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times
                              */

      /*
            //4.Hex, binary and octal numbers

            //Hexadecimal
            //JavaScript interprets numeric constants as hexadecimal if they are preceded by 0x.

            let x33 = 0xff;
            console.log(x33);

            console.log(0xff); // 255
            console.log(0xff); // 255 (the same, case doesn't matter)

            //Binary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:

            let a = 0b11111111; // binary form of 255
            let b = 0o377; // octal form of 255

            console.log(a == b); // true, the same number 255 at both sides

            //5.toString(base)
            //The method num.toString(base) returns a string representation of num in the numeral system with the given base.

            //For example:

            let num = 255;

            console.log(num.toString(16)); // ff
            console.log(num.toString(2)); // 11111111
      */
      /*
                              Common use cases for this are:

                              base=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.

                              base=2 is mostly for debugging bitwise operations, digits can be 0 or 1.

                              base=36 is the maximum, digits can be 0..9 or A..Z. The whole latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral system with base 36:

                              console.log( 123456..toString(36) ); // 2n9c

                              */

      /*
            let myNumber1 = 32;
            myNumber.toString(32);
            myNumber.toString(16);
            myNumber.toString(12);
            myNumber.toString(10);
            myNumber.toString(8);
            myNumber.toString(2);

            //5.Imprecise calculations
            console.log(1e500); // Infinity
            console.log(0.1 + 0.2 == 0.3); // false
            console.log(0.1 + 0.2); // 0.30000000000000004

            //6.Tests: isFinite and isNaN

            //i.isNaN(value) converts its argument to a number and then tests it for being NaN:

            console.log(isNaN(NaN)); // true
            console.log(isNaN("str")); // true

            console.log(NaN === NaN); // false

            //ii.isFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:

            console.log(isFinite("15")); // true
            console.log(isFinite("str")); // false, because a special value: NaN
            console.log(isFinite(Infinity)); // false, because a special value: Infinity

            //Sometimes isFinite is used to validate whether a string value is a regular number:

            let num2 = +prompt("Enter a number", "");

            // will be true unless you enter Infinity, -Infinity or not a number
            console.log(isFinite(num2));

            //iii.Number.isNaN(value) returns true if the argument belongs to the number type and it is NaN. In any other case it returns false.

            console.log(Number.isNaN(NaN)); // true
            console.log(Number.isNaN("str" / 2)); // true

            // Note the difference:
            console.log(Number.isNaN("str")); // false, because "str" belongs to the string type, not the number type
            console.log(isNaN("str")); // true, because isNaN converts string "str" into a number and gets NaN as a result of this conversion

            //iv.Number.isFinite(value) returns true if the argument belongs to the number type and it is not NaN/Infinity/-Infinity. In any other case it returns false.

            console.log(Number.isFinite(123)); // true
            console.log(Number.isFinite(Infinity)); // false
            console.log(Number.isFinite(2 / 0)); // false

            // Note the difference:
            console.log(Number.isFinite("123")); // false, because "123" belongs to the string type, not the number type
            console.log(isFinite("123")); // true, because isFinite converts string "123" into a number 123
          */
    </script>

    <!--<script src="./script.js"></script>-->
  </body>
</html>
